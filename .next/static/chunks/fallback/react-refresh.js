// runtime can't be in strict mode because a global variable is assign and maybe created.
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-refresh"],{

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js ***!
  \********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/**\n * MIT License\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ var __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n// This file is copied from the Metro JavaScript bundler, with minor tweaks for\n// webpack 4 compatibility.\n//\n// https://github.com/facebook/metro/blob/d6b9685c730d0d63577db40f41369157f28dfa3a/packages/metro/src/lib/polyfills/require.js\nconst runtime_1 = __importDefault(__webpack_require__(/*! next/dist/compiled/react-refresh/runtime */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/react-refresh/runtime.js\"));\nfunction isSafeExport(key) {\n    return key === '__esModule' || key === '__N_SSG' || key === '__N_SSP' || // TODO: remove this key from page config instead of allow listing it\n    key === 'config';\n}\nfunction registerExportsForReactRefresh(moduleExports, moduleID) {\n    runtime_1.default.register(moduleExports, moduleID + ' %exports%');\n    if (moduleExports == null || typeof moduleExports !== 'object') {\n        // Exit if we can't iterate over exports.\n        // (This is important for legacy environments.)\n        return;\n    }\n    for(var key in moduleExports){\n        if (isSafeExport(key)) {\n            continue;\n        }\n        try {\n            var exportValue = moduleExports[key];\n        } catch (_a) {\n            continue;\n        }\n        var typeID = moduleID + ' %exports% ' + key;\n        runtime_1.default.register(exportValue, typeID);\n    }\n}\nfunction getRefreshBoundarySignature(moduleExports) {\n    var signature = [];\n    signature.push(runtime_1.default.getFamilyByType(moduleExports));\n    if (moduleExports == null || typeof moduleExports !== 'object') {\n        // Exit if we can't iterate over exports.\n        // (This is important for legacy environments.)\n        return signature;\n    }\n    for(var key in moduleExports){\n        if (isSafeExport(key)) {\n            continue;\n        }\n        try {\n            var exportValue = moduleExports[key];\n        } catch (_a) {\n            continue;\n        }\n        signature.push(key);\n        signature.push(runtime_1.default.getFamilyByType(exportValue));\n    }\n    return signature;\n}\nfunction isReactRefreshBoundary(moduleExports) {\n    if (runtime_1.default.isLikelyComponentType(moduleExports)) {\n        return true;\n    }\n    if (moduleExports == null || typeof moduleExports !== 'object') {\n        // Exit if we can't iterate over exports.\n        return false;\n    }\n    var hasExports = false;\n    var areAllExportsComponents = true;\n    for(var key in moduleExports){\n        hasExports = true;\n        if (isSafeExport(key)) {\n            continue;\n        }\n        try {\n            var exportValue = moduleExports[key];\n        } catch (_a) {\n            // This might fail due to circular dependencies\n            return false;\n        }\n        if (!runtime_1.default.isLikelyComponentType(exportValue)) {\n            areAllExportsComponents = false;\n        }\n    }\n    return hasExports && areAllExportsComponents;\n}\nfunction shouldInvalidateReactRefreshBoundary(prevSignature, nextSignature) {\n    if (prevSignature.length !== nextSignature.length) {\n        return true;\n    }\n    for(var i = 0; i < nextSignature.length; i++){\n        if (prevSignature[i] !== nextSignature[i]) {\n            return true;\n        }\n    }\n    return false;\n}\nvar isUpdateScheduled = false;\n// This function aggregates updates from multiple modules into a single React Refresh call.\nfunction scheduleUpdate() {\n    if (isUpdateScheduled) {\n        return;\n    }\n    isUpdateScheduled = true;\n    function canApplyUpdate(status) {\n        return status === 'idle';\n    }\n    function applyUpdate() {\n        isUpdateScheduled = false;\n        try {\n            runtime_1.default.performReactRefresh();\n        } catch (err) {\n            console.warn('Warning: Failed to re-render. We will retry on the next Fast Refresh event.\\n' + err);\n        }\n    }\n    if (canApplyUpdate(module.hot.status())) {\n        // Apply update on the next tick.\n        Promise.resolve().then(()=>{\n            applyUpdate();\n        });\n        return;\n    }\n    const statusHandler = (status)=>{\n        if (canApplyUpdate(status)) {\n            module.hot.removeStatusHandler(statusHandler);\n            applyUpdate();\n        }\n    };\n    // Apply update once the HMR runtime's status is idle.\n    module.hot.addStatusHandler(statusHandler);\n}\n// Needs to be compatible with IE11\nexports[\"default\"] = {\n    registerExportsForReactRefresh: registerExportsForReactRefresh,\n    isReactRefreshBoundary: isReactRefreshBoundary,\n    shouldInvalidateReactRefreshBoundary: shouldInvalidateReactRefreshBoundary,\n    getRefreshBoundarySignature: getRefreshBoundarySignature,\n    scheduleUpdate: scheduleUpdate\n}; //# sourceMappingURL=helpers.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtcmVmcmVzaC11dGlscy9kaXN0L2ludGVybmFsL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0JHOzs7Ozs7OztBQUVILCtFQUErRTtBQUMvRSwyQkFBMkI7QUFDM0IsRUFBRTtBQUNGLDhIQUE4SDtBQUU5SCxzTEFBa0Q7QUFzQmxELFNBQVMsWUFBWSxDQUFDLEdBQVc7SUFDL0IsT0FBTyxHQUNGLEtBQUssWUFBWSxJQUNwQixHQUFHLEtBQUssU0FBUyxJQUNqQixHQUFHLEtBQUssU0FBUyxJQUNqQixxRUFBcUU7SUFDckUsR0FBRyxLQUFLLFFBQVEsQ0FDakI7QUFDSCxDQUFDO0FBRUQsU0FBUyw4QkFBOEIsQ0FDckMsYUFBc0IsRUFDdEIsUUFBZ0I7SUFFaEIsaUJBQWMsQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFFLFFBQVEsR0FBRyxZQUFZLENBQUM7SUFDL0QsSUFBSSxhQUFhLElBQUksSUFBSSxJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQy9ELHlDQUF5QztRQUN6QywrQ0FBK0M7UUFDL0MsT0FBTTtJQUNSLENBQUM7SUFDRCxJQUFLLElBQUksR0FBRyxJQUFJLGFBQWEsQ0FBRSxDQUFDO1FBQzlCLElBQUksWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDdEIsU0FBUTtRQUNWLENBQUM7UUFDRCxJQUFJLENBQUM7WUFDSCxJQUFJLFdBQVcsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDO1FBQ3RDLENBQUMsQ0FBQyxXQUFNLENBQUM7WUFFUCxTQUFRO1FBQ1YsQ0FBQztRQUNELElBQUksTUFBTSxHQUFHLFFBQVEsR0FBRyxhQUFhLEdBQUcsR0FBRztRQUMzQyxpQkFBYyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDO0lBQzlDLENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBUywyQkFBMkIsQ0FBQyxhQUFzQjtJQUN6RCxJQUFJLFNBQVMsR0FBRyxFQUFFO0lBQ2xCLFNBQVMsQ0FBQyxJQUFJLENBQUMsaUJBQWMsQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDN0QsSUFBSSxhQUFhLElBQUksSUFBSSxJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQy9ELHlDQUF5QztRQUN6QywrQ0FBK0M7UUFDL0MsT0FBTyxTQUFTO0lBQ2xCLENBQUM7SUFDRCxJQUFLLElBQUksR0FBRyxJQUFJLGFBQWEsQ0FBRSxDQUFDO1FBQzlCLElBQUksWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDdEIsU0FBUTtRQUNWLENBQUM7UUFDRCxJQUFJLENBQUM7WUFDSCxJQUFJLFdBQVcsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDO1FBQ3RDLENBQUMsQ0FBQyxXQUFNLENBQUM7WUFFUCxTQUFRO1FBQ1YsQ0FBQztRQUNELFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ25CLFNBQVMsQ0FBQyxJQUFJLENBQUMsaUJBQWMsQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUNELE9BQU8sU0FBUztBQUNsQixDQUFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxhQUFzQjtJQUNwRCxJQUFJLGlCQUFjLENBQUMscUJBQXFCLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQztRQUN4RCxPQUFPLElBQUk7SUFDYixDQUFDO0lBQ0QsSUFBSSxhQUFhLElBQUksSUFBSSxJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQy9ELHlDQUF5QztRQUN6QyxPQUFPLEtBQUs7SUFDZCxDQUFDO0lBQ0QsSUFBSSxVQUFVLEdBQUcsS0FBSztJQUN0QixJQUFJLHVCQUF1QixHQUFHLElBQUk7SUFDbEMsSUFBSyxJQUFJLEdBQUcsSUFBSSxhQUFhLENBQUUsQ0FBQztRQUM5QixVQUFVLEdBQUcsSUFBSTtRQUNqQixJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3RCLFNBQVE7UUFDVixDQUFDO1FBQ0QsSUFBSSxDQUFDO1lBQ0gsSUFBSSxXQUFXLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQztRQUN0QyxDQUFDLENBQUMsV0FBTSxDQUFDO1lBQ1AsK0NBQStDO1lBQy9DLE9BQU8sS0FBSztRQUNkLENBQUM7UUFDRCxJQUFJLENBQUMsaUJBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDO1lBQ3ZELHVCQUF1QixHQUFHLEtBQUs7UUFDakMsQ0FBQztJQUNILENBQUM7SUFDRCxPQUFPLFVBQVUsSUFBSSx1QkFBdUI7QUFDOUMsQ0FBQztBQUVELFNBQVMsb0NBQW9DLENBQzNDLGFBQXdCLEVBQ3hCLGFBQXdCO0lBRXhCLElBQUksYUFBYSxDQUFDLE1BQU0sS0FBSyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDbEQsT0FBTyxJQUFJO0lBQ2IsQ0FBQztJQUNELElBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFFLENBQUM7UUFDOUMsSUFBSSxhQUFhLENBQUMsQ0FBQyxDQUFDLEtBQUssYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDMUMsT0FBTyxJQUFJO1FBQ2IsQ0FBQztJQUNILENBQUM7SUFDRCxPQUFPLEtBQUs7QUFDZCxDQUFDO0FBRUQsSUFBSSxpQkFBaUIsR0FBWSxLQUFLO0FBQ3RDLDJGQUEyRjtBQUMzRixTQUFTLGNBQWM7SUFDckIsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO1FBQ3RCLE9BQU07SUFDUixDQUFDO0lBQ0QsaUJBQWlCLEdBQUcsSUFBSTtJQUV4QixTQUFTLGNBQWMsQ0FBQyxNQUF1QjtRQUM3QyxPQUFPLE1BQU0sS0FBSyxNQUFNO0lBQzFCLENBQUM7SUFFRCxTQUFTLFdBQVc7UUFDbEIsaUJBQWlCLEdBQUcsS0FBSztRQUN6QixJQUFJLENBQUM7WUFDSCxpQkFBYyxDQUFDLG1CQUFtQixFQUFFO1FBQ3RDLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2IsT0FBTyxDQUFDLElBQUksQ0FDViwrRUFBK0UsR0FDN0UsR0FBRyxDQUNOO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFFRCxJQUFJLGNBQWMsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ3hDLGlDQUFpQztRQUNqQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUMxQixXQUFXLEVBQUU7UUFDZixDQUFDLENBQUM7UUFDRixPQUFNO0lBQ1IsQ0FBQztJQUVELE1BQU0sYUFBYSxHQUFHLENBQUMsTUFBTSxFQUFFLEVBQUU7UUFDL0IsSUFBSSxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztZQUMzQixVQUFVLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDO1lBQzdDLFdBQVcsRUFBRTtRQUNmLENBQUM7SUFDSCxDQUFDO0lBRUQsc0RBQXNEO0lBQ3RELFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUM7QUFDNUMsQ0FBQztBQUVELG1DQUFtQztBQUNuQyxxQkFBZTtJQUNiLDhCQUE4QixFQUFFLDhCQUE4QjtJQUM5RCxzQkFBc0IsRUFBRSxzQkFBc0I7SUFDOUMsb0NBQW9DLEVBQUUsb0NBQW9DO0lBQzFFLDJCQUEyQixFQUFFLDJCQUEyQjtJQUN4RCxjQUFjLEVBQUUsY0FBYztDQUMvQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxpbnRlcm5hbFxcaGVscGVycy50cyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst runtime_1 = __importDefault(__webpack_require__(/*! next/dist/compiled/react-refresh/runtime */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/react-refresh/runtime.js\"));\nconst helpers_1 = __importDefault(__webpack_require__(/*! ./internal/helpers */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js\"));\n// Hook into ReactDOM initialization\nruntime_1.default.injectIntoGlobalHook(self);\n// Register global helpers\nself.$RefreshHelpers$ = helpers_1.default;\n// Register a helper for module execution interception\nself.$RefreshInterceptModuleExecution$ = function(webpackModuleId) {\n    var prevRefreshReg = self.$RefreshReg$;\n    var prevRefreshSig = self.$RefreshSig$;\n    self.$RefreshReg$ = function(type, id) {\n        runtime_1.default.register(type, webpackModuleId + ' ' + id);\n    };\n    self.$RefreshSig$ = runtime_1.default.createSignatureFunctionForTransform;\n    // Modeled after `useEffect` cleanup pattern:\n    // https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed\n    return function() {\n        self.$RefreshReg$ = prevRefreshReg;\n        self.$RefreshSig$ = prevRefreshSig;\n    };\n}; //# sourceMappingURL=runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtcmVmcmVzaC11dGlscy9kaXN0L3J1bnRpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsc0xBQWtEO0FBQ2xELDZMQUErQztBQVcvQyxvQ0FBb0M7QUFDcEMsaUJBQWMsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUM7QUFFekMsMEJBQTBCO0FBQzFCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxpQkFBYztBQUV0QyxzREFBc0Q7QUFDdEQsSUFBSSxDQUFDLGlDQUFpQyxHQUFHLFNBQVUsZUFBZTtJQUNoRSxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWTtJQUN0QyxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWTtJQUV0QyxJQUFJLENBQUMsWUFBWSxHQUFHLFNBQVUsSUFBSSxFQUFFLEVBQUU7UUFDcEMsaUJBQWMsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLGVBQWUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQzNELENBQUM7SUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLGlCQUFjLENBQUMsbUNBQW1DO0lBRXRFLDZDQUE2QztJQUM3QyxrRkFBa0Y7SUFDbEYsT0FBTztRQUNMLElBQUksQ0FBQyxZQUFZLEdBQUcsY0FBYztRQUNsQyxJQUFJLENBQUMsWUFBWSxHQUFHLGNBQWM7SUFDcEMsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxccnVudGltZS50cyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        'use strict';\n        // ATTENTION\n        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n        var REACT_MEMO_TYPE = Symbol.for('react.memo');\n        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\n        // It's OK to reference families, but use WeakMap/Set for types.\n        var allFamiliesByID = new Map();\n        var allFamiliesByType = new PossiblyWeakMap();\n        var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n        // that have actually been edited here. This keeps checks fast.\n        // $FlowIssue\n        var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n        // It is an array of [Family, NextType] tuples.\n        var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n        var helpersByRendererID = new Map();\n        var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n        var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\n        var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\n        // It needs to be weak because we do this even for roots that failed to mount.\n        // If there is no WeakMap, we won't attempt to do retrying.\n        // $FlowIssue\n        var rootElements = typeof WeakMap === 'function' ? new WeakMap() : null;\n        var isPerformingRefresh = false;\n        function computeFullKey(signature) {\n            if (signature.fullKey !== null) {\n                return signature.fullKey;\n            }\n            var fullKey = signature.ownKey;\n            var hooks;\n            try {\n                hooks = signature.getCustomHooks();\n            } catch (err) {\n                // This can happen in an edge case, e.g. if expression like Foo.useSomething\n                // depends on Foo which is lazily initialized during rendering.\n                // In that case just assume we'll have to remount.\n                signature.forceReset = true;\n                signature.fullKey = fullKey;\n                return fullKey;\n            }\n            for(var i = 0; i < hooks.length; i++){\n                var hook = hooks[i];\n                if (typeof hook !== 'function') {\n                    // Something's wrong. Assume we need to remount.\n                    signature.forceReset = true;\n                    signature.fullKey = fullKey;\n                    return fullKey;\n                }\n                var nestedHookSignature = allSignaturesByType.get(hook);\n                if (nestedHookSignature === undefined) {\n                    continue;\n                }\n                var nestedHookKey = computeFullKey(nestedHookSignature);\n                if (nestedHookSignature.forceReset) {\n                    signature.forceReset = true;\n                }\n                fullKey += '\\n---\\n' + nestedHookKey;\n            }\n            signature.fullKey = fullKey;\n            return fullKey;\n        }\n        function haveEqualSignatures(prevType, nextType) {\n            var prevSignature = allSignaturesByType.get(prevType);\n            var nextSignature = allSignaturesByType.get(nextType);\n            if (prevSignature === undefined && nextSignature === undefined) {\n                return true;\n            }\n            if (prevSignature === undefined || nextSignature === undefined) {\n                return false;\n            }\n            if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n                return false;\n            }\n            if (nextSignature.forceReset) {\n                return false;\n            }\n            return true;\n        }\n        function isReactClass(type) {\n            return type.prototype && type.prototype.isReactComponent;\n        }\n        function canPreserveStateBetween(prevType, nextType) {\n            if (isReactClass(prevType) || isReactClass(nextType)) {\n                return false;\n            }\n            if (haveEqualSignatures(prevType, nextType)) {\n                return true;\n            }\n            return false;\n        }\n        function resolveFamily(type) {\n            // Only check updated types to keep lookups fast.\n            return updatedFamiliesByType.get(type);\n        } // If we didn't care about IE11, we could use new Map/Set(iterable).\n        function cloneMap(map) {\n            var clone = new Map();\n            map.forEach(function(value, key) {\n                clone.set(key, value);\n            });\n            return clone;\n        }\n        function cloneSet(set) {\n            var clone = new Set();\n            set.forEach(function(value) {\n                clone.add(value);\n            });\n            return clone;\n        } // This is a safety mechanism to protect against rogue getters and Proxies.\n        function getProperty(object, property) {\n            try {\n                return object[property];\n            } catch (err) {\n                // Intentionally ignore.\n                return undefined;\n            }\n        }\n        function performReactRefresh() {\n            if (pendingUpdates.length === 0) {\n                return null;\n            }\n            if (isPerformingRefresh) {\n                return null;\n            }\n            isPerformingRefresh = true;\n            try {\n                var staleFamilies = new Set();\n                var updatedFamilies = new Set();\n                var updates = pendingUpdates;\n                pendingUpdates = [];\n                updates.forEach(function(_ref) {\n                    var family = _ref[0], nextType = _ref[1];\n                    // Now that we got a real edit, we can create associations\n                    // that will be read by the React reconciler.\n                    var prevType = family.current;\n                    updatedFamiliesByType.set(prevType, family);\n                    updatedFamiliesByType.set(nextType, family);\n                    family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n                    if (canPreserveStateBetween(prevType, nextType)) {\n                        updatedFamilies.add(family);\n                    } else {\n                        staleFamilies.add(family);\n                    }\n                }); // TODO: rename these fields to something more meaningful.\n                var update = {\n                    updatedFamilies: updatedFamilies,\n                    // Families that will re-render preserving state\n                    staleFamilies: staleFamilies // Families that will be remounted\n                };\n                helpersByRendererID.forEach(function(helpers) {\n                    // Even if there are no roots, set the handler on first update.\n                    // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n                    helpers.setRefreshHandler(resolveFamily);\n                });\n                var didError = false;\n                var firstError = null; // We snapshot maps and sets that are mutated during commits.\n                // If we don't do this, there is a risk they will be mutated while\n                // we iterate over them. For example, trying to recover a failed root\n                // may cause another root to be added to the failed list -- an infinite loop.\n                var failedRootsSnapshot = cloneSet(failedRoots);\n                var mountedRootsSnapshot = cloneSet(mountedRoots);\n                var helpersByRootSnapshot = cloneMap(helpersByRoot);\n                failedRootsSnapshot.forEach(function(root) {\n                    var helpers = helpersByRootSnapshot.get(root);\n                    if (helpers === undefined) {\n                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n                    }\n                    if (!failedRoots.has(root)) {}\n                    if (rootElements === null) {\n                        return;\n                    }\n                    if (!rootElements.has(root)) {\n                        return;\n                    }\n                    var element = rootElements.get(root);\n                    try {\n                        helpers.scheduleRoot(root, element);\n                    } catch (err) {\n                        if (!didError) {\n                            didError = true;\n                            firstError = err;\n                        } // Keep trying other roots.\n                    }\n                });\n                mountedRootsSnapshot.forEach(function(root) {\n                    var helpers = helpersByRootSnapshot.get(root);\n                    if (helpers === undefined) {\n                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n                    }\n                    if (!mountedRoots.has(root)) {}\n                    try {\n                        helpers.scheduleRefresh(root, update);\n                    } catch (err) {\n                        if (!didError) {\n                            didError = true;\n                            firstError = err;\n                        } // Keep trying other roots.\n                    }\n                });\n                if (didError) {\n                    throw firstError;\n                }\n                return update;\n            } finally{\n                isPerformingRefresh = false;\n            }\n        }\n        function register(type, id) {\n            {\n                if (type === null) {\n                    return;\n                }\n                if (typeof type !== 'function' && typeof type !== 'object') {\n                    return;\n                } // This can happen in an edge case, e.g. if we register\n                // return value of a HOC but it returns a cached component.\n                // Ignore anything but the first registration for each type.\n                if (allFamiliesByType.has(type)) {\n                    return;\n                } // Create family or remember to update it.\n                // None of this bookkeeping affects reconciliation\n                // until the first performReactRefresh() call above.\n                var family = allFamiliesByID.get(id);\n                if (family === undefined) {\n                    family = {\n                        current: type\n                    };\n                    allFamiliesByID.set(id, family);\n                } else {\n                    pendingUpdates.push([\n                        family,\n                        type\n                    ]);\n                }\n                allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n                if (typeof type === 'object' && type !== null) {\n                    switch(getProperty(type, '$$typeof')){\n                        case REACT_FORWARD_REF_TYPE:\n                            register(type.render, id + '$render');\n                            break;\n                        case REACT_MEMO_TYPE:\n                            register(type.type, id + '$type');\n                            break;\n                    }\n                }\n            }\n        }\n        function setSignature(type, key) {\n            var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n            {\n                if (!allSignaturesByType.has(type)) {\n                    allSignaturesByType.set(type, {\n                        forceReset: forceReset,\n                        ownKey: key,\n                        fullKey: null,\n                        getCustomHooks: getCustomHooks || function() {\n                            return [];\n                        }\n                    });\n                } // Visit inner types because we might not have signed them.\n                if (typeof type === 'object' && type !== null) {\n                    switch(getProperty(type, '$$typeof')){\n                        case REACT_FORWARD_REF_TYPE:\n                            setSignature(type.render, key, forceReset, getCustomHooks);\n                            break;\n                        case REACT_MEMO_TYPE:\n                            setSignature(type.type, key, forceReset, getCustomHooks);\n                            break;\n                    }\n                }\n            }\n        } // This is lazily called during first render for a type.\n        // It captures Hook list at that time so inline requires don't break comparisons.\n        function collectCustomHooksForSignature(type) {\n            {\n                var signature = allSignaturesByType.get(type);\n                if (signature !== undefined) {\n                    computeFullKey(signature);\n                }\n            }\n        }\n        function getFamilyByID(id) {\n            {\n                return allFamiliesByID.get(id);\n            }\n        }\n        function getFamilyByType(type) {\n            {\n                return allFamiliesByType.get(type);\n            }\n        }\n        function findAffectedHostInstances(families) {\n            {\n                var affectedInstances = new Set();\n                mountedRoots.forEach(function(root) {\n                    var helpers = helpersByRoot.get(root);\n                    if (helpers === undefined) {\n                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n                    }\n                    var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n                    instancesForRoot.forEach(function(inst) {\n                        affectedInstances.add(inst);\n                    });\n                });\n                return affectedInstances;\n            }\n        }\n        function injectIntoGlobalHook(globalObject) {\n            {\n                // For React Native, the global hook will be set up by require('react-devtools-core').\n                // That code will run before us. So we need to monkeypatch functions on existing hook.\n                // For React Web, the global hook will be set up by the extension.\n                // This will also run before us.\n                var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n                if (hook === undefined) {\n                    // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n                    // Note that in this case it's important that renderer code runs *after* this method call.\n                    // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n                    var nextID = 0;\n                    globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n                        renderers: new Map(),\n                        supportsFiber: true,\n                        inject: function(injected) {\n                            return nextID++;\n                        },\n                        onScheduleFiberRoot: function(id, root, children) {},\n                        onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {},\n                        onCommitFiberUnmount: function() {}\n                    };\n                }\n                if (hook.isDisabled) {\n                    // This isn't a real property on the hook, but it can be set to opt out\n                    // of DevTools integration and associated warnings and logs.\n                    // Using console['warn'] to evade Babel and ESLint\n                    console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');\n                    return;\n                } // Here, we just want to get a reference to scheduleRefresh.\n                var oldInject = hook.inject;\n                hook.inject = function(injected) {\n                    var id = oldInject.apply(this, arguments);\n                    if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n                        // This version supports React Refresh.\n                        helpersByRendererID.set(id, injected);\n                    }\n                    return id;\n                }; // Do the same for any already injected roots.\n                // This is useful if ReactDOM has already been initialized.\n                // https://github.com/facebook/react/issues/17626\n                hook.renderers.forEach(function(injected, id) {\n                    if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n                        // This version supports React Refresh.\n                        helpersByRendererID.set(id, injected);\n                    }\n                }); // We also want to track currently mounted roots.\n                var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n                var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {};\n                hook.onScheduleFiberRoot = function(id, root, children) {\n                    if (!isPerformingRefresh) {\n                        // If it was intentionally scheduled, don't attempt to restore.\n                        // This includes intentionally scheduled unmounts.\n                        failedRoots.delete(root);\n                        if (rootElements !== null) {\n                            rootElements.set(root, children);\n                        }\n                    }\n                    return oldOnScheduleFiberRoot.apply(this, arguments);\n                };\n                hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {\n                    var helpers = helpersByRendererID.get(id);\n                    if (helpers !== undefined) {\n                        helpersByRoot.set(root, helpers);\n                        var current = root.current;\n                        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n                        // This logic is copy-pasted from similar logic in the DevTools backend.\n                        // If this breaks with some refactoring, you'll want to update DevTools too.\n                        if (alternate !== null) {\n                            var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n                            var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n                            if (!wasMounted && isMounted) {\n                                // Mount a new root.\n                                mountedRoots.add(root);\n                                failedRoots.delete(root);\n                            } else if (wasMounted && isMounted) ;\n                            else if (wasMounted && !isMounted) {\n                                // Unmount an existing root.\n                                mountedRoots.delete(root);\n                                if (didError) {\n                                    // We'll remount it on future edits.\n                                    failedRoots.add(root);\n                                } else {\n                                    helpersByRoot.delete(root);\n                                }\n                            } else if (!wasMounted && !isMounted) {\n                                if (didError) {\n                                    // We'll remount it on future edits.\n                                    failedRoots.add(root);\n                                }\n                            }\n                        } else {\n                            // Mount a new root.\n                            mountedRoots.add(root);\n                        }\n                    } // Always call the decorated DevTools hook.\n                    return oldOnCommitFiberRoot.apply(this, arguments);\n                };\n            }\n        }\n        function hasUnrecoverableErrors() {\n            // TODO: delete this after removing dependency in RN.\n            return false;\n        } // Exposed for testing.\n        function _getMountedRootCount() {\n            {\n                return mountedRoots.size;\n            }\n        } // This is a wrapper over more primitive functions for setting signature.\n        // Signatures let us decide whether the Hook order has changed on refresh.\n        //\n        // This function is intended to be used as a transform target, e.g.:\n        // var _s = createSignatureFunctionForTransform()\n        //\n        // function Hello() {\n        //   const [foo, setFoo] = useState(0);\n        //   const value = useCustomHook();\n        //   _s(); /* Call without arguments triggers collecting the custom Hook list.\n        //          * This doesn't happen during the module evaluation because we\n        //          * don't want to change the module order with inline requires.\n        //          * Next calls are noops. */\n        //   return <h1>Hi</h1>;\n        // }\n        //\n        // /* Call with arguments attaches the signature to the type: */\n        // _s(\n        //   Hello,\n        //   'useState{[foo, setFoo]}(0)',\n        //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n        // );\n        function createSignatureFunctionForTransform() {\n            {\n                var savedType;\n                var hasCustomHooks;\n                var didCollectHooks = false;\n                return function(type, key, forceReset, getCustomHooks) {\n                    if (typeof key === 'string') {\n                        // We're in the initial phase that associates signatures\n                        // with the functions. Note this may be called multiple times\n                        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\n                        if (!savedType) {\n                            // We're in the innermost call, so this is the actual type.\n                            savedType = type;\n                            hasCustomHooks = typeof getCustomHooks === 'function';\n                        } // Set the signature for all types (even wrappers!) in case\n                        // they have no signatures of their own. This is to prevent\n                        // problems like https://github.com/facebook/react/issues/20417.\n                        if (type != null && (typeof type === 'function' || typeof type === 'object')) {\n                            setSignature(type, key, forceReset, getCustomHooks);\n                        }\n                        return type;\n                    } else {\n                        // We're in the _s() call without arguments, which means\n                        // this is the time to collect custom Hook signatures.\n                        // Only do this once. This path is hot and runs *inside* every render!\n                        if (!didCollectHooks && hasCustomHooks) {\n                            didCollectHooks = true;\n                            collectCustomHooksForSignature(savedType);\n                        }\n                    }\n                };\n            }\n        }\n        function isLikelyComponentType(type) {\n            {\n                switch(typeof type){\n                    case 'function':\n                        {\n                            // First, deal with classes.\n                            if (type.prototype != null) {\n                                if (type.prototype.isReactComponent) {\n                                    // React class.\n                                    return true;\n                                }\n                                var ownNames = Object.getOwnPropertyNames(type.prototype);\n                                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n                                    // This looks like a class.\n                                    return false;\n                                } // eslint-disable-next-line no-proto\n                                if (type.prototype.__proto__ !== Object.prototype) {\n                                    // It has a superclass.\n                                    return false;\n                                } // Pass through.\n                            // This looks like a regular function with empty prototype.\n                            } // For plain functions and arrows, use name as a heuristic.\n                            var name = type.name || type.displayName;\n                            return typeof name === 'string' && /^[A-Z]/.test(name);\n                        }\n                    case 'object':\n                        {\n                            if (type != null) {\n                                switch(getProperty(type, '$$typeof')){\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                        // Definitely React components.\n                                        return true;\n                                    default:\n                                        return false;\n                                }\n                            }\n                            return false;\n                        }\n                    default:\n                        {\n                            return false;\n                        }\n                }\n            }\n        }\n        exports._getMountedRootCount = _getMountedRootCount;\n        exports.collectCustomHooksForSignature = collectCustomHooksForSignature;\n        exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\n        exports.findAffectedHostInstances = findAffectedHostInstances;\n        exports.getFamilyByID = getFamilyByID;\n        exports.getFamilyByType = getFamilyByType;\n        exports.hasUnrecoverableErrors = hasUnrecoverableErrors;\n        exports.injectIntoGlobalHook = injectIntoGlobalHook;\n        exports.isLikelyComponentType = isLikelyComponentType;\n        exports.performReactRefresh = performReactRefresh;\n        exports.register = register;\n        exports.setSignature = setSignature;\n    })();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtcmVmcmVzaC9janMvcmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRVk7QUFFYixJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDO1FBQ0g7UUFFQSxZQUFZO1FBQ1osSUFBSUMseUJBQXlCQyxPQUFPQyxHQUFHLENBQUM7UUFDeEMsSUFBSUMsa0JBQWtCRixPQUFPQyxHQUFHLENBQUM7UUFFakMsSUFBSUUsa0JBQWtCLE9BQU9DLFlBQVksYUFBYUEsVUFBVUMsS0FBSyxzQ0FBc0M7UUFDM0csZ0VBQWdFO1FBRWhFLElBQUlDLGtCQUFrQixJQUFJRDtRQUMxQixJQUFJRSxvQkFBb0IsSUFBSUo7UUFDNUIsSUFBSUssc0JBQXNCLElBQUlMLG1CQUFtQix5REFBeUQ7UUFDMUcsK0RBQStEO1FBQy9ELGFBQWE7UUFFYixJQUFJTSx3QkFBd0IsSUFBSU4sbUJBQW1CLHVEQUF1RDtRQUMxRywrQ0FBK0M7UUFFL0MsSUFBSU8saUJBQWlCLEVBQUUsRUFBRSw2REFBNkQ7UUFFdEYsSUFBSUMsc0JBQXNCLElBQUlOO1FBQzlCLElBQUlPLGdCQUFnQixJQUFJUCxPQUFPLDZEQUE2RDtRQUU1RixJQUFJUSxlQUFlLElBQUlDLE9BQU8sdUVBQXVFO1FBRXJHLElBQUlDLGNBQWMsSUFBSUQsT0FBTywwRkFBMEY7UUFDdkgsOEVBQThFO1FBQzlFLDJEQUEyRDtRQUMzRCxhQUFhO1FBRWIsSUFBSUUsZUFDSixPQUFPWixZQUFZLGFBQWEsSUFBSUEsWUFBWTtRQUNoRCxJQUFJYSxzQkFBc0I7UUFFMUIsU0FBU0MsZUFBZUMsU0FBUztZQUMvQixJQUFJQSxVQUFVQyxPQUFPLEtBQUssTUFBTTtnQkFDOUIsT0FBT0QsVUFBVUMsT0FBTztZQUMxQjtZQUVBLElBQUlBLFVBQVVELFVBQVVFLE1BQU07WUFDOUIsSUFB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UjtRQUNoQ1EsMkJBQTJCLEdBQUczRTtRQUM5QjJFLGdCQUFnQixHQUFHdEQ7UUFDbkJzRCxvQkFBb0IsR0FBR2xEO0lBQ3JCO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQWRtaW5pc3RyYXRvclxcRGVza3RvcFxcU2VyYXBoaW5lX0h5YnJpZF9WMV9BcHBcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0LXJlZnJlc2hcXGNqc1xccmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlZnJlc2gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIEFUVEVOVElPTlxudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcblxudmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDsgLy8gV2UgbmV2ZXIgcmVtb3ZlIHRoZXNlIGFzc29jaWF0aW9ucy5cbi8vIEl0J3MgT0sgdG8gcmVmZXJlbmNlIGZhbWlsaWVzLCBidXQgdXNlIFdlYWtNYXAvU2V0IGZvciB0eXBlcy5cblxudmFyIGFsbEZhbWlsaWVzQnlJRCA9IG5ldyBNYXAoKTtcbnZhciBhbGxGYW1pbGllc0J5VHlwZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbnZhciBhbGxTaWduYXR1cmVzQnlUeXBlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpOyAvLyBUaGlzIFdlYWtNYXAgaXMgcmVhZCBieSBSZWFjdCwgc28gd2Ugb25seSBwdXQgZmFtaWxpZXNcbi8vIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGVkaXRlZCBoZXJlLiBUaGlzIGtlZXBzIGNoZWNrcyBmYXN0LlxuLy8gJEZsb3dJc3N1ZVxuXG52YXIgdXBkYXRlZEZhbWlsaWVzQnlUeXBlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpOyAvLyBUaGlzIGlzIGNsZWFyZWQgb24gZXZlcnkgcGVyZm9ybVJlYWN0UmVmcmVzaCgpIGNhbGwuXG4vLyBJdCBpcyBhbiBhcnJheSBvZiBbRmFtaWx5LCBOZXh0VHlwZV0gdHVwbGVzLlxuXG52YXIgcGVuZGluZ1VwZGF0ZXMgPSBbXTsgLy8gVGhpcyBpcyBpbmplY3RlZCBieSB0aGUgcmVuZGVyZXIgdmlhIERldlRvb2xzIGdsb2JhbCBob29rLlxuXG52YXIgaGVscGVyc0J5UmVuZGVyZXJJRCA9IG5ldyBNYXAoKTtcbnZhciBoZWxwZXJzQnlSb290ID0gbmV3IE1hcCgpOyAvLyBXZSBrZWVwIHRyYWNrIG9mIG1vdW50ZWQgcm9vdHMgc28gd2UgY2FuIHNjaGVkdWxlIHVwZGF0ZXMuXG5cbnZhciBtb3VudGVkUm9vdHMgPSBuZXcgU2V0KCk7IC8vIElmIGEgcm9vdCBjYXB0dXJlcyBhbiBlcnJvciwgd2UgcmVtZW1iZXIgaXQgc28gd2UgY2FuIHJldHJ5IG9uIGVkaXQuXG5cbnZhciBmYWlsZWRSb290cyA9IG5ldyBTZXQoKTsgLy8gSW4gZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBXZWFrTWFwLCB3ZSBhbHNvIHJlbWVtYmVyIHRoZSBsYXN0IGVsZW1lbnQgZm9yIGV2ZXJ5IHJvb3QuXG4vLyBJdCBuZWVkcyB0byBiZSB3ZWFrIGJlY2F1c2Ugd2UgZG8gdGhpcyBldmVuIGZvciByb290cyB0aGF0IGZhaWxlZCB0byBtb3VudC5cbi8vIElmIHRoZXJlIGlzIG5vIFdlYWtNYXAsIHdlIHdvbid0IGF0dGVtcHQgdG8gZG8gcmV0cnlpbmcuXG4vLyAkRmxvd0lzc3VlXG5cbnZhciByb290RWxlbWVudHMgPSAvLyAkRmxvd0lzc3VlXG50eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBXZWFrTWFwKCkgOiBudWxsO1xudmFyIGlzUGVyZm9ybWluZ1JlZnJlc2ggPSBmYWxzZTtcblxuZnVuY3Rpb24gY29tcHV0ZUZ1bGxLZXkoc2lnbmF0dXJlKSB7XG4gIGlmIChzaWduYXR1cmUuZnVsbEtleSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzaWduYXR1cmUuZnVsbEtleTtcbiAgfVxuXG4gIHZhciBmdWxsS2V5ID0gc2lnbmF0dXJlLm93bktleTtcbiAgdmFyIGhvb2tzO1xuXG4gIHRyeSB7XG4gICAgaG9va3MgPSBzaWduYXR1cmUuZ2V0Q3VzdG9tSG9va3MoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIGFuIGVkZ2UgY2FzZSwgZS5nLiBpZiBleHByZXNzaW9uIGxpa2UgRm9vLnVzZVNvbWV0aGluZ1xuICAgIC8vIGRlcGVuZHMgb24gRm9vIHdoaWNoIGlzIGxhemlseSBpbml0aWFsaXplZCBkdXJpbmcgcmVuZGVyaW5nLlxuICAgIC8vIEluIHRoYXQgY2FzZSBqdXN0IGFzc3VtZSB3ZSdsbCBoYXZlIHRvIHJlbW91bnQuXG4gICAgc2lnbmF0dXJlLmZvcmNlUmVzZXQgPSB0cnVlO1xuICAgIHNpZ25hdHVyZS5mdWxsS2V5ID0gZnVsbEtleTtcbiAgICByZXR1cm4gZnVsbEtleTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBob29rICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBTb21ldGhpbmcncyB3cm9uZy4gQXNzdW1lIHdlIG5lZWQgdG8gcmVtb3VudC5cbiAgICAgIHNpZ25hdHVyZS5mb3JjZVJlc2V0ID0gdHJ1ZTtcbiAgICAgIHNpZ25hdHVyZS5mdWxsS2V5ID0gZnVsbEtleTtcbiAgICAgIHJldHVybiBmdWxsS2V5O1xuICAgIH1cblxuICAgIHZhciBuZXN0ZWRIb29rU2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQoaG9vayk7XG5cbiAgICBpZiAobmVzdGVkSG9va1NpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBObyBzaWduYXR1cmUgbWVhbnMgSG9vayB3YXNuJ3QgaW4gdGhlIHNvdXJjZSBjb2RlLCBlLmcuIGluIGEgbGlicmFyeS5cbiAgICAgIC8vIFdlJ2xsIHNraXAgaXQgYmVjYXVzZSB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGNoYW5nZSBkdXJpbmcgdGhpcyBzZXNzaW9uLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5lc3RlZEhvb2tLZXkgPSBjb21wdXRlRnVsbEtleShuZXN0ZWRIb29rU2lnbmF0dXJlKTtcblxuICAgIGlmIChuZXN0ZWRIb29rU2lnbmF0dXJlLmZvcmNlUmVzZXQpIHtcbiAgICAgIHNpZ25hdHVyZS5mb3JjZVJlc2V0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdWxsS2V5ICs9ICdcXG4tLS1cXG4nICsgbmVzdGVkSG9va0tleTtcbiAgfVxuXG4gIHNpZ25hdHVyZS5mdWxsS2V5ID0gZnVsbEtleTtcbiAgcmV0dXJuIGZ1bGxLZXk7XG59XG5cbmZ1bmN0aW9uIGhhdmVFcXVhbFNpZ25hdHVyZXMocHJldlR5cGUsIG5leHRUeXBlKSB7XG4gIHZhciBwcmV2U2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQocHJldlR5cGUpO1xuICB2YXIgbmV4dFNpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KG5leHRUeXBlKTtcblxuICBpZiAocHJldlNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkICYmIG5leHRTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHByZXZTaWduYXR1cmUgPT09IHVuZGVmaW5lZCB8fCBuZXh0U2lnbmF0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY29tcHV0ZUZ1bGxLZXkocHJldlNpZ25hdHVyZSkgIT09IGNvbXB1dGVGdWxsS2V5KG5leHRTaWduYXR1cmUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5leHRTaWduYXR1cmUuZm9yY2VSZXNldCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1JlYWN0Q2xhc3ModHlwZSkge1xuICByZXR1cm4gdHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gY2FuUHJlc2VydmVTdGF0ZUJldHdlZW4ocHJldlR5cGUsIG5leHRUeXBlKSB7XG4gIGlmIChpc1JlYWN0Q2xhc3MocHJldlR5cGUpIHx8IGlzUmVhY3RDbGFzcyhuZXh0VHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaGF2ZUVxdWFsU2lnbmF0dXJlcyhwcmV2VHlwZSwgbmV4dFR5cGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGYW1pbHkodHlwZSkge1xuICAvLyBPbmx5IGNoZWNrIHVwZGF0ZWQgdHlwZXMgdG8ga2VlcCBsb29rdXBzIGZhc3QuXG4gIHJldHVybiB1cGRhdGVkRmFtaWxpZXNCeVR5cGUuZ2V0KHR5cGUpO1xufSAvLyBJZiB3ZSBkaWRuJ3QgY2FyZSBhYm91dCBJRTExLCB3ZSBjb3VsZCB1c2UgbmV3IE1hcC9TZXQoaXRlcmFibGUpLlxuXG5cbmZ1bmN0aW9uIGNsb25lTWFwKG1hcCkge1xuICB2YXIgY2xvbmUgPSBuZXcgTWFwKCk7XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgY2xvbmUuc2V0KGtleSwgdmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGNsb25lO1xufVxuXG5mdW5jdGlvbiBjbG9uZVNldChzZXQpIHtcbiAgdmFyIGNsb25lID0gbmV3IFNldCgpO1xuICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBjbG9uZS5hZGQodmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGNsb25lO1xufSAvLyBUaGlzIGlzIGEgc2FmZXR5IG1lY2hhbmlzbSB0byBwcm90ZWN0IGFnYWluc3Qgcm9ndWUgZ2V0dGVycyBhbmQgUHJveGllcy5cblxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eV07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIEludGVudGlvbmFsbHkgaWdub3JlLlxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVJlYWN0UmVmcmVzaCgpIHtcblxuICBpZiAocGVuZGluZ1VwZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaXNQZXJmb3JtaW5nUmVmcmVzaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaXNQZXJmb3JtaW5nUmVmcmVzaCA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgc3RhbGVGYW1pbGllcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdXBkYXRlZEZhbWlsaWVzID0gbmV3IFNldCgpO1xuICAgIHZhciB1cGRhdGVzID0gcGVuZGluZ1VwZGF0ZXM7XG4gICAgcGVuZGluZ1VwZGF0ZXMgPSBbXTtcbiAgICB1cGRhdGVzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBmYW1pbHkgPSBfcmVmWzBdLFxuICAgICAgICAgIG5leHRUeXBlID0gX3JlZlsxXTtcbiAgICAgIC8vIE5vdyB0aGF0IHdlIGdvdCBhIHJlYWwgZWRpdCwgd2UgY2FuIGNyZWF0ZSBhc3NvY2lhdGlvbnNcbiAgICAgIC8vIHRoYXQgd2lsbCBiZSByZWFkIGJ5IHRoZSBSZWFjdCByZWNvbmNpbGVyLlxuICAgICAgdmFyIHByZXZUeXBlID0gZmFtaWx5LmN1cnJlbnQ7XG4gICAgICB1cGRhdGVkRmFtaWxpZXNCeVR5cGUuc2V0KHByZXZUeXBlLCBmYW1pbHkpO1xuICAgICAgdXBkYXRlZEZhbWlsaWVzQnlUeXBlLnNldChuZXh0VHlwZSwgZmFtaWx5KTtcbiAgICAgIGZhbWlseS5jdXJyZW50ID0gbmV4dFR5cGU7IC8vIERldGVybWluZSB3aGV0aGVyIHRoaXMgc2hvdWxkIGJlIGEgcmUtcmVuZGVyIG9yIGEgcmUtbW91bnQuXG5cbiAgICAgIGlmIChjYW5QcmVzZXJ2ZVN0YXRlQmV0d2VlbihwcmV2VHlwZSwgbmV4dFR5cGUpKSB7XG4gICAgICAgIHVwZGF0ZWRGYW1pbGllcy5hZGQoZmFtaWx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWxlRmFtaWxpZXMuYWRkKGZhbWlseSk7XG4gICAgICB9XG4gICAgfSk7IC8vIFRPRE86IHJlbmFtZSB0aGVzZSBmaWVsZHMgdG8gc29tZXRoaW5nIG1vcmUgbWVhbmluZ2Z1bC5cblxuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICB1cGRhdGVkRmFtaWxpZXM6IHVwZGF0ZWRGYW1pbGllcyxcbiAgICAgIC8vIEZhbWlsaWVzIHRoYXQgd2lsbCByZS1yZW5kZXIgcHJlc2VydmluZyBzdGF0ZVxuICAgICAgc3RhbGVGYW1pbGllczogc3RhbGVGYW1pbGllcyAvLyBGYW1pbGllcyB0aGF0IHdpbGwgYmUgcmVtb3VudGVkXG5cbiAgICB9O1xuICAgIGhlbHBlcnNCeVJlbmRlcmVySUQuZm9yRWFjaChmdW5jdGlvbiAoaGVscGVycykge1xuICAgICAgLy8gRXZlbiBpZiB0aGVyZSBhcmUgbm8gcm9vdHMsIHNldCB0aGUgaGFuZGxlciBvbiBmaXJzdCB1cGRhdGUuXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBpZiAqbmV3KiByb290cyBhcmUgbW91bnRlZCwgdGhleSdsbCB1c2UgdGhlIHJlc29sdmUgaGFuZGxlci5cbiAgICAgIGhlbHBlcnMuc2V0UmVmcmVzaEhhbmRsZXIocmVzb2x2ZUZhbWlseSk7XG4gICAgfSk7XG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGZpcnN0RXJyb3IgPSBudWxsOyAvLyBXZSBzbmFwc2hvdCBtYXBzIGFuZCBzZXRzIHRoYXQgYXJlIG11dGF0ZWQgZHVyaW5nIGNvbW1pdHMuXG4gICAgLy8gSWYgd2UgZG9uJ3QgZG8gdGhpcywgdGhlcmUgaXMgYSByaXNrIHRoZXkgd2lsbCBiZSBtdXRhdGVkIHdoaWxlXG4gICAgLy8gd2UgaXRlcmF0ZSBvdmVyIHRoZW0uIEZvciBleGFtcGxlLCB0cnlpbmcgdG8gcmVjb3ZlciBhIGZhaWxlZCByb290XG4gICAgLy8gbWF5IGNhdXNlIGFub3RoZXIgcm9vdCB0byBiZSBhZGRlZCB0byB0aGUgZmFpbGVkIGxpc3QgLS0gYW4gaW5maW5pdGUgbG9vcC5cblxuICAgIHZhciBmYWlsZWRSb290c1NuYXBzaG90ID0gY2xvbmVTZXQoZmFpbGVkUm9vdHMpO1xuICAgIHZhciBtb3VudGVkUm9vdHNTbmFwc2hvdCA9IGNsb25lU2V0KG1vdW50ZWRSb290cyk7XG4gICAgdmFyIGhlbHBlcnNCeVJvb3RTbmFwc2hvdCA9IGNsb25lTWFwKGhlbHBlcnNCeVJvb3QpO1xuICAgIGZhaWxlZFJvb3RzU25hcHNob3QuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgdmFyIGhlbHBlcnMgPSBoZWxwZXJzQnlSb290U25hcHNob3QuZ2V0KHJvb3QpO1xuXG4gICAgICBpZiAoaGVscGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZmFpbGVkUm9vdHMuaGFzKHJvb3QpKSB7Ly8gTm8gbG9uZ2VyIGZhaWxlZC5cbiAgICAgIH1cblxuICAgICAgaWYgKHJvb3RFbGVtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdEVsZW1lbnRzLmhhcyhyb290KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gcm9vdEVsZW1lbnRzLmdldChyb290KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaGVscGVycy5zY2hlZHVsZVJvb3Qocm9vdCwgZWxlbWVudCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFkaWRFcnJvcikge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyO1xuICAgICAgICB9IC8vIEtlZXAgdHJ5aW5nIG90aGVyIHJvb3RzLlxuXG4gICAgICB9XG4gICAgfSk7XG4gICAgbW91bnRlZFJvb3RzU25hcHNob3QuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgdmFyIGhlbHBlcnMgPSBoZWxwZXJzQnlSb290U25hcHNob3QuZ2V0KHJvb3QpO1xuXG4gICAgICBpZiAoaGVscGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbW91bnRlZFJvb3RzLmhhcyhyb290KSkgey8vIE5vIGxvbmdlciBtb3VudGVkLlxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBoZWxwZXJzLnNjaGVkdWxlUmVmcmVzaChyb290LCB1cGRhdGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZGlkRXJyb3IpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZmlyc3RFcnJvciA9IGVycjtcbiAgICAgICAgfSAvLyBLZWVwIHRyeWluZyBvdGhlciByb290cy5cblxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICB0aHJvdyBmaXJzdEVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGU7XG4gIH0gZmluYWxseSB7XG4gICAgaXNQZXJmb3JtaW5nUmVmcmVzaCA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiByZWdpc3Rlcih0eXBlLCBpZCkge1xuICB7XG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gYW4gZWRnZSBjYXNlLCBlLmcuIGlmIHdlIHJlZ2lzdGVyXG4gICAgLy8gcmV0dXJuIHZhbHVlIG9mIGEgSE9DIGJ1dCBpdCByZXR1cm5zIGEgY2FjaGVkIGNvbXBvbmVudC5cbiAgICAvLyBJZ25vcmUgYW55dGhpbmcgYnV0IHRoZSBmaXJzdCByZWdpc3RyYXRpb24gZm9yIGVhY2ggdHlwZS5cblxuXG4gICAgaWYgKGFsbEZhbWlsaWVzQnlUeXBlLmhhcyh0eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ3JlYXRlIGZhbWlseSBvciByZW1lbWJlciB0byB1cGRhdGUgaXQuXG4gICAgLy8gTm9uZSBvZiB0aGlzIGJvb2trZWVwaW5nIGFmZmVjdHMgcmVjb25jaWxpYXRpb25cbiAgICAvLyB1bnRpbCB0aGUgZmlyc3QgcGVyZm9ybVJlYWN0UmVmcmVzaCgpIGNhbGwgYWJvdmUuXG5cblxuICAgIHZhciBmYW1pbHkgPSBhbGxGYW1pbGllc0J5SUQuZ2V0KGlkKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmFtaWx5ID0ge1xuICAgICAgICBjdXJyZW50OiB0eXBlXG4gICAgICB9O1xuICAgICAgYWxsRmFtaWxpZXNCeUlELnNldChpZCwgZmFtaWx5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1VwZGF0ZXMucHVzaChbZmFtaWx5LCB0eXBlXSk7XG4gICAgfVxuXG4gICAgYWxsRmFtaWxpZXNCeVR5cGUuc2V0KHR5cGUsIGZhbWlseSk7IC8vIFZpc2l0IGlubmVyIHR5cGVzIGJlY2F1c2Ugd2UgbWlnaHQgbm90IGhhdmUgcmVnaXN0ZXJlZCB0aGVtLlxuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKGdldFByb3BlcnR5KHR5cGUsICckJHR5cGVvZicpKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICByZWdpc3Rlcih0eXBlLnJlbmRlciwgaWQgKyAnJHJlbmRlcicpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgIHJlZ2lzdGVyKHR5cGUudHlwZSwgaWQgKyAnJHR5cGUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFNpZ25hdHVyZSh0eXBlLCBrZXkpIHtcbiAgdmFyIGZvcmNlUmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICB2YXIgZ2V0Q3VzdG9tSG9va3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcblxuICB7XG4gICAgaWYgKCFhbGxTaWduYXR1cmVzQnlUeXBlLmhhcyh0eXBlKSkge1xuICAgICAgYWxsU2lnbmF0dXJlc0J5VHlwZS5zZXQodHlwZSwge1xuICAgICAgICBmb3JjZVJlc2V0OiBmb3JjZVJlc2V0LFxuICAgICAgICBvd25LZXk6IGtleSxcbiAgICAgICAgZnVsbEtleTogbnVsbCxcbiAgICAgICAgZ2V0Q3VzdG9tSG9va3M6IGdldEN1c3RvbUhvb2tzIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gVmlzaXQgaW5uZXIgdHlwZXMgYmVjYXVzZSB3ZSBtaWdodCBub3QgaGF2ZSBzaWduZWQgdGhlbS5cblxuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKGdldFByb3BlcnR5KHR5cGUsICckJHR5cGVvZicpKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICBzZXRTaWduYXR1cmUodHlwZS5yZW5kZXIsIGtleSwgZm9yY2VSZXNldCwgZ2V0Q3VzdG9tSG9va3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgIHNldFNpZ25hdHVyZSh0eXBlLnR5cGUsIGtleSwgZm9yY2VSZXNldCwgZ2V0Q3VzdG9tSG9va3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBUaGlzIGlzIGxhemlseSBjYWxsZWQgZHVyaW5nIGZpcnN0IHJlbmRlciBmb3IgYSB0eXBlLlxuLy8gSXQgY2FwdHVyZXMgSG9vayBsaXN0IGF0IHRoYXQgdGltZSBzbyBpbmxpbmUgcmVxdWlyZXMgZG9uJ3QgYnJlYWsgY29tcGFyaXNvbnMuXG5cbmZ1bmN0aW9uIGNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZSh0eXBlKSB7XG4gIHtcbiAgICB2YXIgc2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQodHlwZSk7XG5cbiAgICBpZiAoc2lnbmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbXB1dGVGdWxsS2V5KHNpZ25hdHVyZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRGYW1pbHlCeUlEKGlkKSB7XG4gIHtcbiAgICByZXR1cm4gYWxsRmFtaWxpZXNCeUlELmdldChpZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZhbWlseUJ5VHlwZSh0eXBlKSB7XG4gIHtcbiAgICByZXR1cm4gYWxsRmFtaWxpZXNCeVR5cGUuZ2V0KHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBmaW5kQWZmZWN0ZWRIb3N0SW5zdGFuY2VzKGZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgYWZmZWN0ZWRJbnN0YW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgbW91bnRlZFJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5Um9vdC5nZXQocm9vdCk7XG5cbiAgICAgIGlmIChoZWxwZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBoZWxwZXJzIGZvciBhIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QgUmVmcmVzaC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluc3RhbmNlc0ZvclJvb3QgPSBoZWxwZXJzLmZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaChyb290LCBmYW1pbGllcyk7XG4gICAgICBpbnN0YW5jZXNGb3JSb290LmZvckVhY2goZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXMuYWRkKGluc3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFmZmVjdGVkSW5zdGFuY2VzO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3RJbnRvR2xvYmFsSG9vayhnbG9iYWxPYmplY3QpIHtcbiAge1xuICAgIC8vIEZvciBSZWFjdCBOYXRpdmUsIHRoZSBnbG9iYWwgaG9vayB3aWxsIGJlIHNldCB1cCBieSByZXF1aXJlKCdyZWFjdC1kZXZ0b29scy1jb3JlJykuXG4gICAgLy8gVGhhdCBjb2RlIHdpbGwgcnVuIGJlZm9yZSB1cy4gU28gd2UgbmVlZCB0byBtb25rZXlwYXRjaCBmdW5jdGlvbnMgb24gZXhpc3RpbmcgaG9vay5cbiAgICAvLyBGb3IgUmVhY3QgV2ViLCB0aGUgZ2xvYmFsIGhvb2sgd2lsbCBiZSBzZXQgdXAgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICAvLyBUaGlzIHdpbGwgYWxzbyBydW4gYmVmb3JlIHVzLlxuICAgIHZhciBob29rID0gZ2xvYmFsT2JqZWN0Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICAgIGlmIChob29rID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEhvd2V2ZXIsIGlmIHRoZXJlIGlzIG5vIERldlRvb2xzIGV4dGVuc2lvbiwgd2UnbGwgbmVlZCB0byBzZXQgdXAgdGhlIGdsb2JhbCBob29rIG91cnNlbHZlcy5cbiAgICAgIC8vIE5vdGUgdGhhdCBpbiB0aGlzIGNhc2UgaXQncyBpbXBvcnRhbnQgdGhhdCByZW5kZXJlciBjb2RlIHJ1bnMgKmFmdGVyKiB0aGlzIG1ldGhvZCBjYWxsLlxuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgcmVuZGVyZXIgd2lsbCB0aGluayB0aGF0IHRoZXJlIGlzIG5vIGdsb2JhbCBob29rLCBhbmQgd29uJ3QgZG8gdGhlIGluamVjdGlvbi5cbiAgICAgIHZhciBuZXh0SUQgPSAwO1xuICAgICAgZ2xvYmFsT2JqZWN0Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9IGhvb2sgPSB7XG4gICAgICAgIHJlbmRlcmVyczogbmV3IE1hcCgpLFxuICAgICAgICBzdXBwb3J0c0ZpYmVyOiB0cnVlLFxuICAgICAgICBpbmplY3Q6IGZ1bmN0aW9uIChpbmplY3RlZCkge1xuICAgICAgICAgIHJldHVybiBuZXh0SUQrKztcbiAgICAgICAgfSxcbiAgICAgICAgb25TY2hlZHVsZUZpYmVyUm9vdDogZnVuY3Rpb24gKGlkLCByb290LCBjaGlsZHJlbikge30sXG4gICAgICAgIG9uQ29tbWl0RmliZXJSb290OiBmdW5jdGlvbiAoaWQsIHJvb3QsIG1heWJlUHJpb3JpdHlMZXZlbCwgZGlkRXJyb3IpIHt9LFxuICAgICAgICBvbkNvbW1pdEZpYmVyVW5tb3VudDogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgICAgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnU29tZXRoaW5nIGhhcyBzaGltbWVkIHRoZSBSZWFjdCBEZXZUb29scyBnbG9iYWwgaG9vayAoX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKS4gJyArICdGYXN0IFJlZnJlc2ggaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGlzIHNoaW0gYW5kIHdpbGwgYmUgZGlzYWJsZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBIZXJlLCB3ZSBqdXN0IHdhbnQgdG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHNjaGVkdWxlUmVmcmVzaC5cblxuXG4gICAgdmFyIG9sZEluamVjdCA9IGhvb2suaW5qZWN0O1xuXG4gICAgaG9vay5pbmplY3QgPSBmdW5jdGlvbiAoaW5qZWN0ZWQpIHtcbiAgICAgIHZhciBpZCA9IG9sZEluamVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodHlwZW9mIGluamVjdGVkLnNjaGVkdWxlUmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5qZWN0ZWQuc2V0UmVmcmVzaEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVGhpcyB2ZXJzaW9uIHN1cHBvcnRzIFJlYWN0IFJlZnJlc2guXG4gICAgICAgIGhlbHBlcnNCeVJlbmRlcmVySUQuc2V0KGlkLCBpbmplY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZDtcbiAgICB9OyAvLyBEbyB0aGUgc2FtZSBmb3IgYW55IGFscmVhZHkgaW5qZWN0ZWQgcm9vdHMuXG4gICAgLy8gVGhpcyBpcyB1c2VmdWwgaWYgUmVhY3RET00gaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE3NjI2XG5cblxuICAgIGhvb2sucmVuZGVyZXJzLmZvckVhY2goZnVuY3Rpb24gKGluamVjdGVkLCBpZCkge1xuICAgICAgaWYgKHR5cGVvZiBpbmplY3RlZC5zY2hlZHVsZVJlZnJlc2ggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluamVjdGVkLnNldFJlZnJlc2hIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRoaXMgdmVyc2lvbiBzdXBwb3J0cyBSZWFjdCBSZWZyZXNoLlxuICAgICAgICBoZWxwZXJzQnlSZW5kZXJlcklELnNldChpZCwgaW5qZWN0ZWQpO1xuICAgICAgfVxuICAgIH0pOyAvLyBXZSBhbHNvIHdhbnQgdG8gdHJhY2sgY3VycmVudGx5IG1vdW50ZWQgcm9vdHMuXG5cbiAgICB2YXIgb2xkT25Db21taXRGaWJlclJvb3QgPSBob29rLm9uQ29tbWl0RmliZXJSb290O1xuXG4gICAgdmFyIG9sZE9uU2NoZWR1bGVGaWJlclJvb3QgPSBob29rLm9uU2NoZWR1bGVGaWJlclJvb3QgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICBob29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPSBmdW5jdGlvbiAoaWQsIHJvb3QsIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWlzUGVyZm9ybWluZ1JlZnJlc2gpIHtcbiAgICAgICAgLy8gSWYgaXQgd2FzIGludGVudGlvbmFsbHkgc2NoZWR1bGVkLCBkb24ndCBhdHRlbXB0IHRvIHJlc3RvcmUuXG4gICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgaW50ZW50aW9uYWxseSBzY2hlZHVsZWQgdW5tb3VudHMuXG4gICAgICAgIGZhaWxlZFJvb3RzLmRlbGV0ZShyb290KTtcblxuICAgICAgICBpZiAocm9vdEVsZW1lbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgcm9vdEVsZW1lbnRzLnNldChyb290LCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9sZE9uU2NoZWR1bGVGaWJlclJvb3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgaG9vay5vbkNvbW1pdEZpYmVyUm9vdCA9IGZ1bmN0aW9uIChpZCwgcm9vdCwgbWF5YmVQcmlvcml0eUxldmVsLCBkaWRFcnJvcikge1xuICAgICAgdmFyIGhlbHBlcnMgPSBoZWxwZXJzQnlSZW5kZXJlcklELmdldChpZCk7XG5cbiAgICAgIGlmIChoZWxwZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVscGVyc0J5Um9vdC5zZXQocm9vdCwgaGVscGVycyk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICAgICAgICB2YXIgYWx0ZXJuYXRlID0gY3VycmVudC5hbHRlcm5hdGU7IC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyByb290IGhhcyBqdXN0ICh1biltb3VudGVkLlxuICAgICAgICAvLyBUaGlzIGxvZ2ljIGlzIGNvcHktcGFzdGVkIGZyb20gc2ltaWxhciBsb2dpYyBpbiB0aGUgRGV2VG9vbHMgYmFja2VuZC5cbiAgICAgICAgLy8gSWYgdGhpcyBicmVha3Mgd2l0aCBzb21lIHJlZmFjdG9yaW5nLCB5b3UnbGwgd2FudCB0byB1cGRhdGUgRGV2VG9vbHMgdG9vLlxuXG4gICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgd2FzTW91bnRlZCA9IGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICE9IG51bGwgJiYgYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuZWxlbWVudCAhPSBudWxsICYmIG1vdW50ZWRSb290cy5oYXMocm9vdCk7XG4gICAgICAgICAgdmFyIGlzTW91bnRlZCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ICE9IG51bGw7XG5cbiAgICAgICAgICBpZiAoIXdhc01vdW50ZWQgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAvLyBNb3VudCBhIG5ldyByb290LlxuICAgICAgICAgICAgbW91bnRlZFJvb3RzLmFkZChyb290KTtcbiAgICAgICAgICAgIGZhaWxlZFJvb3RzLmRlbGV0ZShyb290KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdhc01vdW50ZWQgJiYgaXNNb3VudGVkKSA7IGVsc2UgaWYgKHdhc01vdW50ZWQgJiYgIWlzTW91bnRlZCkge1xuICAgICAgICAgICAgLy8gVW5tb3VudCBhbiBleGlzdGluZyByb290LlxuICAgICAgICAgICAgbW91bnRlZFJvb3RzLmRlbGV0ZShyb290KTtcblxuICAgICAgICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIFdlJ2xsIHJlbW91bnQgaXQgb24gZnV0dXJlIGVkaXRzLlxuICAgICAgICAgICAgICBmYWlsZWRSb290cy5hZGQocm9vdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWxwZXJzQnlSb290LmRlbGV0ZShyb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCF3YXNNb3VudGVkICYmICFpc01vdW50ZWQpIHtcbiAgICAgICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgICAgICAvLyBXZSdsbCByZW1vdW50IGl0IG9uIGZ1dHVyZSBlZGl0cy5cbiAgICAgICAgICAgICAgZmFpbGVkUm9vdHMuYWRkKHJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNb3VudCBhIG5ldyByb290LlxuICAgICAgICAgIG1vdW50ZWRSb290cy5hZGQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQWx3YXlzIGNhbGwgdGhlIGRlY29yYXRlZCBEZXZUb29scyBob29rLlxuXG5cbiAgICAgIHJldHVybiBvbGRPbkNvbW1pdEZpYmVyUm9vdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc1VucmVjb3ZlcmFibGVFcnJvcnMoKSB7XG4gIC8vIFRPRE86IGRlbGV0ZSB0aGlzIGFmdGVyIHJlbW92aW5nIGRlcGVuZGVuY3kgaW4gUk4uXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gRXhwb3NlZCBmb3IgdGVzdGluZy5cblxuZnVuY3Rpb24gX2dldE1vdW50ZWRSb290Q291bnQoKSB7XG4gIHtcbiAgICByZXR1cm4gbW91bnRlZFJvb3RzLnNpemU7XG4gIH1cbn0gLy8gVGhpcyBpcyBhIHdyYXBwZXIgb3ZlciBtb3JlIHByaW1pdGl2ZSBmdW5jdGlvbnMgZm9yIHNldHRpbmcgc2lnbmF0dXJlLlxuLy8gU2lnbmF0dXJlcyBsZXQgdXMgZGVjaWRlIHdoZXRoZXIgdGhlIEhvb2sgb3JkZXIgaGFzIGNoYW5nZWQgb24gcmVmcmVzaC5cbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYSB0cmFuc2Zvcm0gdGFyZ2V0LCBlLmcuOlxuLy8gdmFyIF9zID0gY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0oKVxuLy9cbi8vIGZ1bmN0aW9uIEhlbGxvKCkge1xuLy8gICBjb25zdCBbZm9vLCBzZXRGb29dID0gdXNlU3RhdGUoMCk7XG4vLyAgIGNvbnN0IHZhbHVlID0gdXNlQ3VzdG9tSG9vaygpO1xuLy8gICBfcygpOyAvKiBDYWxsIHdpdGhvdXQgYXJndW1lbnRzIHRyaWdnZXJzIGNvbGxlY3RpbmcgdGhlIGN1c3RvbSBIb29rIGxpc3QuXG4vLyAgICAgICAgICAqIFRoaXMgZG9lc24ndCBoYXBwZW4gZHVyaW5nIHRoZSBtb2R1bGUgZXZhbHVhdGlvbiBiZWNhdXNlIHdlXG4vLyAgICAgICAgICAqIGRvbid0IHdhbnQgdG8gY2hhbmdlIHRoZSBtb2R1bGUgb3JkZXIgd2l0aCBpbmxpbmUgcmVxdWlyZXMuXG4vLyAgICAgICAgICAqIE5leHQgY2FsbHMgYXJlIG5vb3BzLiAqL1xuLy8gICByZXR1cm4gPGgxPkhpPC9oMT47XG4vLyB9XG4vL1xuLy8gLyogQ2FsbCB3aXRoIGFyZ3VtZW50cyBhdHRhY2hlcyB0aGUgc2lnbmF0dXJlIHRvIHRoZSB0eXBlOiAqL1xuLy8gX3MoXG4vLyAgIEhlbGxvLFxuLy8gICAndXNlU3RhdGV7W2Zvbywgc2V0Rm9vXX0oMCknLFxuLy8gICAoKSA9PiBbdXNlQ3VzdG9tSG9va10sIC8qIExhenkgdG8gYXZvaWQgdHJpZ2dlcmluZyBpbmxpbmUgcmVxdWlyZXMgKi9cbi8vICk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNpZ25hdHVyZUZ1bmN0aW9uRm9yVHJhbnNmb3JtKCkge1xuICB7XG4gICAgdmFyIHNhdmVkVHlwZTtcbiAgICB2YXIgaGFzQ3VzdG9tSG9va3M7XG4gICAgdmFyIGRpZENvbGxlY3RIb29rcyA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAodHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcykge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFdlJ3JlIGluIHRoZSBpbml0aWFsIHBoYXNlIHRoYXQgYXNzb2NpYXRlcyBzaWduYXR1cmVzXG4gICAgICAgIC8vIHdpdGggdGhlIGZ1bmN0aW9ucy4gTm90ZSB0aGlzIG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgLy8gaW4gSE9DIGNoYWlucyBsaWtlIF9zKGhvYzEoX3MoaG9jMihfcyhhY3R1YWxGdW5jdGlvbikpKSkpLlxuICAgICAgICBpZiAoIXNhdmVkVHlwZSkge1xuICAgICAgICAgIC8vIFdlJ3JlIGluIHRoZSBpbm5lcm1vc3QgY2FsbCwgc28gdGhpcyBpcyB0aGUgYWN0dWFsIHR5cGUuXG4gICAgICAgICAgc2F2ZWRUeXBlID0gdHlwZTtcbiAgICAgICAgICBoYXNDdXN0b21Ib29rcyA9IHR5cGVvZiBnZXRDdXN0b21Ib29rcyA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfSAvLyBTZXQgdGhlIHNpZ25hdHVyZSBmb3IgYWxsIHR5cGVzIChldmVuIHdyYXBwZXJzISkgaW4gY2FzZVxuICAgICAgICAvLyB0aGV5IGhhdmUgbm8gc2lnbmF0dXJlcyBvZiB0aGVpciBvd24uIFRoaXMgaXMgdG8gcHJldmVudFxuICAgICAgICAvLyBwcm9ibGVtcyBsaWtlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjA0MTcuXG5cblxuICAgICAgICBpZiAodHlwZSAhPSBudWxsICYmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgc2V0U2lnbmF0dXJlKHR5cGUsIGtleSwgZm9yY2VSZXNldCwgZ2V0Q3VzdG9tSG9va3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSdyZSBpbiB0aGUgX3MoKSBjYWxsIHdpdGhvdXQgYXJndW1lbnRzLCB3aGljaCBtZWFuc1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSB0aW1lIHRvIGNvbGxlY3QgY3VzdG9tIEhvb2sgc2lnbmF0dXJlcy5cbiAgICAgICAgLy8gT25seSBkbyB0aGlzIG9uY2UuIFRoaXMgcGF0aCBpcyBob3QgYW5kIHJ1bnMgKmluc2lkZSogZXZlcnkgcmVuZGVyIVxuICAgICAgICBpZiAoIWRpZENvbGxlY3RIb29rcyAmJiBoYXNDdXN0b21Ib29rcykge1xuICAgICAgICAgIGRpZENvbGxlY3RIb29rcyA9IHRydWU7XG4gICAgICAgICAgY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlKHNhdmVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc0xpa2VseUNvbXBvbmVudFR5cGUodHlwZSkge1xuICB7XG4gICAgc3dpdGNoICh0eXBlb2YgdHlwZSkge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gRmlyc3QsIGRlYWwgd2l0aCBjbGFzc2VzLlxuICAgICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAvLyBSZWFjdCBjbGFzcy5cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvd25OYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHR5cGUucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgaWYgKG93bk5hbWVzLmxlbmd0aCA+IDEgfHwgb3duTmFtZXNbMF0gIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIGEgY2xhc3MuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG5cblxuICAgICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAvLyBJdCBoYXMgYSBzdXBlcmNsYXNzLlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IC8vIFBhc3MgdGhyb3VnaC5cbiAgICAgICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhIHJlZ3VsYXIgZnVuY3Rpb24gd2l0aCBlbXB0eSBwcm90b3R5cGUuXG5cbiAgICAgICAgICB9IC8vIEZvciBwbGFpbiBmdW5jdGlvbnMgYW5kIGFycm93cywgdXNlIG5hbWUgYXMgYSBoZXVyaXN0aWMuXG5cblxuICAgICAgICAgIHZhciBuYW1lID0gdHlwZS5uYW1lIHx8IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiAvXltBLVpdLy50ZXN0KG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGdldFByb3BlcnR5KHR5cGUsICckJHR5cGVvZicpKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgLy8gRGVmaW5pdGVseSBSZWFjdCBjb21wb25lbnRzLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuX2dldE1vdW50ZWRSb290Q291bnQgPSBfZ2V0TW91bnRlZFJvb3RDb3VudDtcbmV4cG9ydHMuY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlID0gY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlO1xuZXhwb3J0cy5jcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybSA9IGNyZWF0ZVNpZ25hdHVyZUZ1bmN0aW9uRm9yVHJhbnNmb3JtO1xuZXhwb3J0cy5maW5kQWZmZWN0ZWRIb3N0SW5zdGFuY2VzID0gZmluZEFmZmVjdGVkSG9zdEluc3RhbmNlcztcbmV4cG9ydHMuZ2V0RmFtaWx5QnlJRCA9IGdldEZhbWlseUJ5SUQ7XG5leHBvcnRzLmdldEZhbWlseUJ5VHlwZSA9IGdldEZhbWlseUJ5VHlwZTtcbmV4cG9ydHMuaGFzVW5yZWNvdmVyYWJsZUVycm9ycyA9IGhhc1VucmVjb3ZlcmFibGVFcnJvcnM7XG5leHBvcnRzLmluamVjdEludG9HbG9iYWxIb29rID0gaW5qZWN0SW50b0dsb2JhbEhvb2s7XG5leHBvcnRzLmlzTGlrZWx5Q29tcG9uZW50VHlwZSA9IGlzTGlrZWx5Q29tcG9uZW50VHlwZTtcbmV4cG9ydHMucGVyZm9ybVJlYWN0UmVmcmVzaCA9IHBlcmZvcm1SZWFjdFJlZnJlc2g7XG5leHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5leHBvcnRzLnNldFNpZ25hdHVyZSA9IHNldFNpZ25hdHVyZTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX01FTU9fVFlQRSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJNYXAiLCJhbGxGYW1pbGllc0J5SUQiLCJhbGxGYW1pbGllc0J5VHlwZSIsImFsbFNpZ25hdHVyZXNCeVR5cGUiLCJ1cGRhdGVkRmFtaWxpZXNCeVR5cGUiLCJwZW5kaW5nVXBkYXRlcyIsImhlbHBlcnNCeVJlbmRlcmVySUQiLCJoZWxwZXJzQnlSb290IiwibW91bnRlZFJvb3RzIiwiU2V0IiwiZmFpbGVkUm9vdHMiLCJyb290RWxlbWVudHMiLCJpc1BlcmZvcm1pbmdSZWZyZXNoIiwiY29tcHV0ZUZ1bGxLZXkiLCJzaWduYXR1cmUiLCJmdWxsS2V5Iiwib3duS2V5IiwiaG9va3MiLCJnZXRDdXN0b21Ib29rcyIsImVyciIsImZvcmNlUmVzZXQiLCJpIiwibGVuZ3RoIiwiaG9vayIsIm5lc3RlZEhvb2tTaWduYXR1cmUiLCJnZXQiLCJ1bmRlZmluZWQiLCJuZXN0ZWRIb29rS2V5IiwiaGF2ZUVxdWFsU2lnbmF0dXJlcyIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJwcmV2U2lnbmF0dXJlIiwibmV4dFNpZ25hdHVyZSIsImlzUmVhY3RDbGFzcyIsInR5cGUiLCJwcm90b3R5cGUiLCJpc1JlYWN0Q29tcG9uZW50IiwiY2FuUHJlc2VydmVTdGF0ZUJldHdlZW4iLCJyZXNvbHZlRmFtaWx5IiwiY2xvbmVNYXAiLCJtYXAiLCJjbG9uZSIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsInNldCIsImNsb25lU2V0IiwiYWRkIiwiZ2V0UHJvcGVydHkiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInBlcmZvcm1SZWFjdFJlZnJlc2giLCJzdGFsZUZhbWlsaWVzIiwidXBkYXRlZEZhbWlsaWVzIiwidXBkYXRlcyIsIl9yZWYiLCJmYW1pbHkiLCJjdXJyZW50IiwidXBkYXRlIiwiaGVscGVycyIsInNldFJlZnJlc2hIYW5kbGVyIiwiZGlkRXJyb3IiLCJmaXJzdEVycm9yIiwiZmFpbGVkUm9vdHNTbmFwc2hvdCIsIm1vdW50ZWRSb290c1NuYXBzaG90IiwiaGVscGVyc0J5Um9vdFNuYXBzaG90Iiwicm9vdCIsIkVycm9yIiwiaGFzIiwiZWxlbWVudCIsInNjaGVkdWxlUm9vdCIsInNjaGVkdWxlUmVmcmVzaCIsInJlZ2lzdGVyIiwiaWQiLCJwdXNoIiwicmVuZGVyIiwic2V0U2lnbmF0dXJlIiwiYXJndW1lbnRzIiwiY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlIiwiZ2V0RmFtaWx5QnlJRCIsImdldEZhbWlseUJ5VHlwZSIsImZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXMiLCJmYW1pbGllcyIsImFmZmVjdGVkSW5zdGFuY2VzIiwiaW5zdGFuY2VzRm9yUm9vdCIsImZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCIsImluc3QiLCJpbmplY3RJbnRvR2xvYmFsSG9vayIsImdsb2JhbE9iamVjdCIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsIm5leHRJRCIsInJlbmRlcmVycyIsInN1cHBvcnRzRmliZXIiLCJpbmplY3QiLCJpbmplY3RlZCIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJjaGlsZHJlbiIsIm9uQ29tbWl0RmliZXJSb290IiwibWF5YmVQcmlvcml0eUxldmVsIiwib25Db21taXRGaWJlclVubW91bnQiLCJpc0Rpc2FibGVkIiwiY29uc29sZSIsIm9sZEluamVjdCIsImFwcGx5Iiwib2xkT25Db21taXRGaWJlclJvb3QiLCJvbGRPblNjaGVkdWxlRmliZXJSb290IiwiZGVsZXRlIiwiYWx0ZXJuYXRlIiwid2FzTW91bnRlZCIsIm1lbW9pemVkU3RhdGUiLCJpc01vdW50ZWQiLCJoYXNVbnJlY292ZXJhYmxlRXJyb3JzIiwiX2dldE1vdW50ZWRSb290Q291bnQiLCJzaXplIiwiY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0iLCJzYXZlZFR5cGUiLCJoYXNDdXN0b21Ib29rcyIsImRpZENvbGxlY3RIb29rcyIsImlzTGlrZWx5Q29tcG9uZW50VHlwZSIsIm93bk5hbWVzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9fcHJvdG9fXyIsIm5hbWUiLCJkaXNwbGF5TmFtZSIsInRlc3QiLCJleHBvcnRzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/react-refresh/runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-refresh/runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-refresh-runtime.development.js */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtcmVmcmVzaC9ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsS0FBcUMsRUFBRSxFQUUxQyxNQUFNO0lBQ0xDLHNNQUFzRTtBQUN4RSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pbmlzdHJhdG9yXFxEZXNrdG9wXFxTZXJhcGhpbmVfSHlicmlkX1YxX0FwcFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3QtcmVmcmVzaFxccnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVmcmVzaC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlZnJlc2gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/compiled/react-refresh/runtime.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js"));
/******/ _N_E = __webpack_exports__;
/******/ }
]);